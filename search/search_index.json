{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Memories (storage)","text":""},{"location":"#_1","title":"\u5229\u7528\u3057\u3066\u3044\u308b\u30e9\u30a4\u30d6\u30e9\u30ea","text":"\u30d1\u30c3\u30b1\u30fc\u30b8\u540d \u30d0\u30fc\u30b8\u30e7\u30f3 \u30e9\u30a4\u30bb\u30f3\u30b9 \u30b5\u30de\u30ea Authlib 1.5.2 BSD-3-Clause The ultimate Python library in building OAuth and OpenID Connect servers and clients. blinker 1.9.0 Fast, simple object-to-object and broadcast signaling boto3 1.38.4 Apache License 2.0 The AWS SDK for Python botocore 1.38.4 Apache License 2.0 Low-level, data-driven core of boto 3. certifi 2025.4.26 MPL-2.0 Python package for providing Mozilla's CA Bundle. cffi 1.17.1 MIT Foreign Function Interface for Python calling C code. charset-normalizer 3.4.1 MIT The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. click 8.1.8 Composable command line interface toolkit cryptography 44.0.2 Apache-2.0 OR BSD-3-Clause cryptography is a package which provides cryptographic recipes and primitives to Python developers. EbookLib 0.18 GNU Affero General Public License Ebook library which can handle EPUB2/EPUB3 and Kindle format Flask 3.1.0 A simple framework for building complex web applications. flask-cors 5.0.1 A Flask extension simplifying CORS support flask-swagger 0.2.14 MIT Extract swagger specs from your flask project flask-swagger-ui 4.11.1 MIT Swagger UI blueprint for Flask gunicorn 23.0.0 MIT WSGI HTTP Server for UNIX idna 3.10 Internationalized Domain Names in Applications (IDNA) itsdangerous 2.2.0 Safely pass data to untrusted environments and back. Jinja2 3.1.6 A very fast and expressive template engine. jmespath 1.0.1 MIT JSON Matching Expressions lxml 5.4.0 BSD-3-Clause Powerful and Pythonic XML processing library combining libxml2/libxslt with the ElementTree API. MarkupSafe 3.0.2 Copyright 2010 Pallets Safely add untrusted strings to HTML/XML markup. numpy 2.2.5 Copyright (c) 2005-2024, NumPy Developers. Fundamental package for array computing in Python opencv-python-headless 4.11.0.86 Apache 2.0 Wrapper package for OpenCV python bindings. packaging 25.0 Core utilities for Python packages pathlib 1.0.1 MIT License Object-oriented filesystem paths pdf2image 1.17.0 MIT A wrapper around the pdftoppm and pdftocairo command line tools to convert PDF to a PIL Image list. piexif 1.1.3 MIT To simplify exif manipulations with python. Writing, reading, and more... pillow 11.2.1 \u4e0d\u660e Python Imaging Library (Fork) pillow_heif 0.22.0 BSD-3-Clause Python interface for libheif library pip 25.1 MIT The PyPA recommended tool for installing Python packages. psycopg2-binary 2.9.10 LGPL with exceptions psycopg2 - Python-PostgreSQL Database Adapter pycparser 2.22 BSD-3-Clause C parser in Python pyheif 0.8.0 Python 3.6+ interface to libheif library PyMuPDF 1.25.5 Dual Licensed - GNU AFFERO GPL 3.0 or Artifex Commercial License A high performance Python library for data extraction, analysis, conversion &amp; manipulation of PDF (and other) documents. python-dateutil 2.9.0.post0 Dual License Extensions to the standard Python datetime module python-docx 1.1.2 MIT Create, read, and update Microsoft Word .docx files. python-dotenv 1.1.0 BSD-3-Clause Read key-value pairs from a .env file and set them as environment variables python-magic 0.4.27 MIT File type identification using libmagic PyYAML 6.0.2 MIT YAML parser and emitter for Python requests 2.32.3 Apache-2.0 Python HTTP for Humans. s3transfer 0.12.0 Apache License 2.0 An Amazon S3 Transfer Manager six 1.17.0 MIT Python 2 and 3 compatibility utilities typing_extensions 4.13.2 \u4e0d\u660e Backported and Experimental Type Hints for Python 3.8+ ulid-py 1.1.0 Apache 2.0 Universally Unique Lexicographically Sortable Identifier urllib3 2.4.0 \u4e0d\u660e HTTP library with thread-safe connection pooling, file post, and more. watchdog 6.0.0 Apache-2.0 Filesystem events monitoring Werkzeug 3.1.3 The comprehensive WSGI web application library."},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This software is dual-licensed:</p> <ul> <li>Non-commercial use: Licensed under the MIT License (with Non-Commercial restriction) \u2014 see LICENSE-NC.txt</li> <li>Commercial use: Requires a separate commercial license \u2014 see LICENSE-COMMERCIAL.txt and contact the author.</li> </ul> <p>You may choose the license that best fits your use case. \ud83d\udd12 A commercial license is an important way to help us keep developing and to ensure you can use the software with confidence.</p> <p>\ud83d\udce7 Contact: forestlaw.me+github@gmail.com</p>"},{"location":"#_2","title":"\u30e9\u30a4\u30bb\u30f3\u30b9\uff08\u65e5\u672c\u8a9e\uff09","text":"<p>\u672c\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306f\u30c7\u30e5\u30a2\u30eb\u30e9\u30a4\u30bb\u30f3\u30b9\u3067\u3059\u3002</p> <ul> <li>\u975e\u5546\u7528\u5229\u7528: \u975e\u5546\u7528 MIT \u30e9\u30a4\u30bb\u30f3\u30b9\uff08LICENSE-NC.txt\uff09\u306e\u6761\u4ef6\u3067\u5229\u7528\u53ef\u80fd</li> <li>\u5546\u7528\u5229\u7528: \u5225\u9014\u5546\u7528\u30e9\u30a4\u30bb\u30f3\u30b9\u304c\u5fc5\u8981\uff08LICENSE-COMMERCIAL.txt \u3092\u53c2\u7167\u3057\u3001\u4f5c\u8005\u306b\u9023\u7d61\uff09</li> </ul> <p>\u7528\u9014\u306b\u5fdc\u3058\u3066\u3001\u9069\u5207\u306a\u30e9\u30a4\u30bb\u30f3\u30b9\u3092\u9078\u629e\u3057\u3066\u304f\u3060\u3055\u3044\u3002 \ud83d\udd12 \u5546\u7528\u30e9\u30a4\u30bb\u30f3\u30b9\u306f\u3001\u307f\u306a\u3055\u307e\u306b\u5b89\u5fc3\u3057\u3066\u4f7f\u3063\u3066\u3044\u305f\u3060\u304f\u305f\u3081\u3001\u305d\u3057\u3066\u958b\u767a\u3092\u7d9a\u3051\u308b\u305f\u3081\u306e\u5927\u5207\u306a\u4ed5\u7d44\u307f\u3067\u3059\u3002 \ud83d\udce7 Contact: forestlaw.me+github@gmail.com</p>"},{"location":"#author","title":"\ud83e\uddd1\u200d\ud83d\udcbb Author","text":"<p>Tsutomu Funada Frontend engineer &amp; Backend engineer &amp; UX designer \ud83d\udce7 Contact: forestlaw.me+github@gmail.com</p>"},{"location":"memories-storage-docs/api/","title":"API","text":""},{"location":"memories-storage-docs/api/#api","title":"api","text":""},{"location":"memories-storage-docs/api/#apiusers_api","title":"api.users_api","text":""},{"location":"memories-storage-docs/api/#log_api_call","title":"log_api_call","text":"<pre><code>def log_api_call(f)\n</code></pre> <p>Decorator to log API calls. This decorator logs the HTTP method and path of the API call.</p> <p>Arguments:</p> <ul> <li><code>f</code> function - The function to be decorated.</li> </ul> <p>Returns:</p> <ul> <li><code>function</code> - The wrapped function with logging functionality.</li> </ul> <p></p>"},{"location":"memories-storage-docs/api/#options_resource","title":"options_resource","text":"<pre><code>@users_bp.route(\"/check\", methods=[\"OPTIONS\"])\n@log_api_call\n@cross_origin()\ndef options_resource()\n</code></pre> <p>Handles CORS preflight request.</p> <p>Returns:</p> <ul> <li><code>Response</code> - Empty JSON response with status code 204.</li> </ul> <p></p>"},{"location":"memories-storage-docs/api/#check_user","title":"check_user","text":"<pre><code>@users_bp.route(\"/check\", methods=[\"POST\"])\n@log_api_call\n@verify_oauth_token\ndef check_user()\n</code></pre> <p>\u30e6\u30fc\u30b6\u30fc\u304c\u767b\u9332\u6e08\u307f\u304b\u78ba\u8a8d</p> <p></p>"},{"location":"memories-storage-docs/api/#register_user","title":"register_user","text":"<pre><code>@users_bp.route(\"/register\", methods=[\"POST\"])\n@log_api_call\n@verify_oauth_token\ndef register_user()\n</code></pre> <p>OAuth \u8a8d\u8a3c\u6e08\u307f\u306e\u30e6\u30fc\u30b6\u30fc\u3092\u767b\u9332\u3057\u3001user_meta \u3092\u4fdd\u5b58</p> <p></p>"},{"location":"memories-storage-docs/api/#apiresource_api","title":"api.resource_api","text":""},{"location":"memories-storage-docs/api/#log_api_call_1","title":"log_api_call","text":"<pre><code>def log_api_call(f)\n</code></pre> <p>Decorator to log API calls. This decorator logs the HTTP method and path of the API call.</p> <p>Arguments:</p> <ul> <li><code>f</code> function - The function to be decorated.</li> </ul> <p>Returns:</p> <ul> <li><code>function</code> - The wrapped function with logging functionality.</li> </ul> <p></p>"},{"location":"memories-storage-docs/api/#create_resource_blueprint","title":"create_resource_blueprint","text":"<pre><code>def create_resource_blueprint(resource_name: str)\n</code></pre> <p>Creates a Flask Blueprint for a given resource.</p> <p>Arguments:</p> <ul> <li><code>resource_name</code> str - The name of the resource.</li> </ul> <p>Returns:</p> <ul> <li><code>Blueprint</code> - The Flask Blueprint object for the specified resource.</li> </ul> <p></p>"},{"location":"memories-storage-docs/api/#apihealth","title":"api.health","text":""},{"location":"memories-storage-docs/api/#health_check","title":"health_check","text":"<pre><code>@health_bp.route(\"/health\", methods=[\"GET\"])\ndef health_check()\n</code></pre> <p>Health check endpoint.</p> <p>Returns:</p> <ul> <li><code>Response</code> - JSON response indicating the service is healthy.</li> </ul> <p></p>"},{"location":"memories-storage-docs/api/#health_options","title":"health_options","text":"<pre><code>@health_bp.route(\"/health\", methods=[\"OPTIONS\"])\n@cross_origin()\ndef health_options()\n</code></pre> <p>Handles CORS preflight request.</p> <p>Returns:</p> <ul> <li><code>Response</code> - Empty JSON response with status code 204.</li> </ul>"},{"location":"memories-storage-docs/auth/","title":"Auth","text":""},{"location":"memories-storage-docs/auth/#auth","title":"auth","text":""},{"location":"memories-storage-docs/auth/#authmicrosoft","title":"auth.microsoft","text":""},{"location":"memories-storage-docs/auth/#authverify_auth_token","title":"auth.verify_auth_token","text":""},{"location":"memories-storage-docs/auth/#verify_oauth_token","title":"verify_oauth_token","text":"<pre><code>def verify_oauth_token(f)\n</code></pre> <p>OAuth \u30c8\u30fc\u30af\u30f3\u3092\u691c\u8a3c\u3057\u3001\u30e6\u30fc\u30b6\u30fc\u60c5\u5831\u3092\u30ea\u30af\u30a8\u30b9\u30c8\u5168\u4f53\u3067\u4fdd\u6301</p> <p></p>"},{"location":"memories-storage-docs/auth/#authenticate_oauth_token","title":"authenticate_oauth_token","text":"<pre><code>def authenticate_oauth_token(token: str)\n</code></pre> <p>Google, Microsoft, GitHub \u306e OAuth \u30c8\u30fc\u30af\u30f3\u3092\u691c\u8a3c</p> <p></p>"},{"location":"memories-storage-docs/auth/#get_user_id","title":"get_user_id","text":"<pre><code>def get_user_id(user_info: dict, provider: str) -&gt; str\n</code></pre> <p>OAuth \u30d7\u30ed\u30d0\u30a4\u30c0\u30fc\u306b\u95a2\u4fc2\u306a\u304f\u7d71\u4e00\u3055\u308c\u305f 36 \u6841\u306e user_id \u3092\u751f\u6210</p> <p></p>"},{"location":"memories-storage-docs/auth/#authfactory","title":"auth.factory","text":""},{"location":"memories-storage-docs/auth/#authutils","title":"auth.utils","text":""},{"location":"memories-storage-docs/auth/#authgoogle","title":"auth.google","text":""},{"location":"memories-storage-docs/auth/#authbase","title":"auth.base","text":""},{"location":"memories-storage-docs/auth/#authgithub","title":"auth.github","text":""},{"location":"memories-storage-docs/auth/#authverify_auth_token_auto","title":"auth.verify_auth_token_auto","text":""},{"location":"memories-storage-docs/config/","title":"Config","text":""},{"location":"memories-storage-docs/config/#config","title":"config","text":""},{"location":"memories-storage-docs/config/#configtypes","title":"config.types","text":""},{"location":"memories-storage-docs/config/#document_mimetype_map","title":"DOCUMENT_MIMETYPE_MAP","text":"<p>dict: Mapping of document file extensions to MIME types.</p> <p></p>"},{"location":"memories-storage-docs/config/#document_filetype_map","title":"DOCUMENT_FILETYPE_MAP","text":"<p>dict: Reverse mapping of document MIME types to file extensions.</p> <p></p>"},{"location":"memories-storage-docs/config/#document_convertible_formats","title":"DOCUMENT_CONVERTIBLE_FORMATS","text":"<p>list: List of document formats that support conversion.</p> <p></p>"},{"location":"memories-storage-docs/config/#image_mimetype_map","title":"IMAGE_MIMETYPE_MAP","text":"<p>dict: Mapping of image file extensions to MIME types.</p> <p></p>"},{"location":"memories-storage-docs/config/#image_filetype_map","title":"IMAGE_FILETYPE_MAP","text":"<p>dict: Reverse mapping of image MIME types to file extensions.</p> <p></p>"},{"location":"memories-storage-docs/config/#audio_mimetype_map","title":"AUDIO_MIMETYPE_MAP","text":"<p>dict: Mapping of audio file extensions to MIME types.</p> <p></p>"},{"location":"memories-storage-docs/config/#video_mimetype_map","title":"VIDEO_MIMETYPE_MAP","text":"<p>dict: Mapping of video file extensions to MIME types.</p> <p></p>"},{"location":"memories-storage-docs/config/#video_filetype_map","title":"VIDEO_FILETYPE_MAP","text":"<p>dict: Reverse mapping of video MIME types to file extensions.</p> <p></p>"},{"location":"memories-storage-docs/config/#full_mimetype_map","title":"FULL_MIMETYPE_MAP","text":"<p>dict: Comprehensive mapping of file extensions to MIME types.</p> <p></p>"},{"location":"memories-storage-docs/config/#allowed_file_mime_types","title":"ALLOWED_FILE_MIME_TYPES","text":"<p>dict: Allowed MIME types categorized by resource type.</p> <p></p>"},{"location":"memories-storage-docs/config/#imagefitmode-objects","title":"ImageFitMode Objects","text":"<pre><code>class ImageFitMode(Enum)\n</code></pre> <p>Enum representing image fit modes.</p> <p></p>"},{"location":"memories-storage-docs/config/#thumbnail_sizes","title":"THUMBNAIL_SIZES","text":"<p>dict: Standard thumbnail sizes with corresponding width and height values.</p> <p></p>"},{"location":"memories-storage-docs/config/#configsettings","title":"config.settings","text":""},{"location":"memories-storage-docs/manager/","title":"Manager","text":""},{"location":"memories-storage-docs/manager/#manager","title":"manager","text":""},{"location":"memories-storage-docs/manager/#managerimage_processor","title":"manager.image_processor","text":""},{"location":"memories-storage-docs/manager/#imageprocessor-objects","title":"ImageProcessor Objects","text":"<pre><code>class ImageProcessor()\n</code></pre>"},{"location":"memories-storage-docs/manager/#convert_image","title":"convert_image","text":"<pre><code>def convert_image(src_path: Union[str, Path, FileStorage, BytesIO],\n                  dest_path: str,\n                  format: Optional[str] = None,\n                  width: Optional[int] = None,\n                  height: Optional[int] = None,\n                  quality: int = 85,\n                  fit_mode: ImageFitMode = ImageFitMode.CONTAIN,\n                  keep_exif: bool = False) -&gt; str\n</code></pre> <p>Convert an image to the specified format and resize it based on <code>fit_mode</code>.</p> <p>Optionally, preserve EXIF metadata if requested.</p> <p>Arguments:</p> <ul> <li><code>src_path</code>: Source image file path</li> <li><code>dest_path</code>: Destination file path where converted image will be saved</li> <li><code>format</code>: Target format (e.g., 'JPEG', 'PNG', 'WEBP', 'BMP', etc.)</li> <li><code>width</code>: Desired width of the bounding box (optional)</li> <li><code>height</code>: Desired height of the bounding box (optional)</li> <li><code>quality</code>: JPEG compression quality (default: 85)</li> <li><code>fit_mode</code>: How the image should fit within the bounding box (ImageFitMode.CONTAIN or ImageFitMode.COVER)</li> <li><code>keep_exif</code>: Whether to retain EXIF metadata (only for supported formats)</li> </ul> <p>Returns:</p> <p>Path to the converted image</p> <p></p>"},{"location":"memories-storage-docs/manager/#update_exif","title":"update_exif","text":"<pre><code>def update_exif(image_file: Union[str, BytesIO, FileStorage,\n                                  Path], mimetype: Optional[str],\n                update_items: Dict[str, Any]) -&gt; Union[bool, BytesIO]\n</code></pre> <p>Updates selective Exif metadata fields of the image.</p> <p>Arguments:</p> <ul> <li>image_file: Input image source</li> <li>mimetype: MIME type of the image</li> <li>update_items: Dictionary of Exif tag \u2192 new value</li> </ul> <p>Returns:</p> <ul> <li>BytesIO: If the input was BytesIO or FileStorage, returns the updated image as BytesIO.</li> <li>True: If the input was a file path and the update succeeded.</li> <li>False: If the update failed</li> </ul> <p></p>"},{"location":"memories-storage-docs/manager/#manageraudio_processor","title":"manager.audio_processor","text":""},{"location":"memories-storage-docs/manager/#audioprocessor-objects","title":"AudioProcessor Objects","text":"<pre><code>class AudioProcessor()\n</code></pre> <p>Class for processing audio files, including format conversion and visualization.</p> <p></p>"},{"location":"memories-storage-docs/manager/#extract_thumbnail_mp4","title":"extract_thumbnail_mp4","text":"<pre><code>def extract_thumbnail_mp4(content_buffer: BytesIO) -&gt; Optional[BytesIO]\n</code></pre> <p>Extracts album art from an MP4/M4A file.</p> <p></p>"},{"location":"memories-storage-docs/manager/#extract_thumbnail_mp3","title":"extract_thumbnail_mp3","text":"<pre><code>def extract_thumbnail_mp3(audio_path: str) -&gt; Optional[BytesIO]\n</code></pre> <p>Extracts album art from an MP3 file.</p> <p></p>"},{"location":"memories-storage-docs/manager/#extract_thumbnail_ogg","title":"extract_thumbnail_ogg","text":"<pre><code>def extract_thumbnail_ogg(audio_path: str) -&gt; Optional[BytesIO]\n</code></pre> <p>Extracts album art from an OGG Vorbis file.</p> <p></p>"},{"location":"memories-storage-docs/manager/#extract_thumbnail_flac","title":"extract_thumbnail_flac","text":"<pre><code>def extract_thumbnail_flac(audio_path: str) -&gt; Optional[BytesIO]\n</code></pre> <p>Extracts album art from a FLAC file.</p> <p></p>"},{"location":"memories-storage-docs/manager/#extract_audio_thumbnail","title":"extract_audio_thumbnail","text":"<pre><code>def extract_audio_thumbnail(content_buffer: BytesIO,\n                            mimetype: str) -&gt; Optional[BytesIO]\n</code></pre> <p>Extracts thumbnail from audio metadata.</p> <p></p>"},{"location":"memories-storage-docs/manager/#convert_audio","title":"convert_audio","text":"<pre><code>def convert_audio(format: str, content: bytes,\n                  mimetype: str) -&gt; Optional[bytes]\n</code></pre> <p>Converts an audio file to the specified format.</p> <p>Arguments:</p> <ul> <li><code>format</code> str - The target audio format (e.g., 'mp3', 'wav').</li> <li><code>content</code> bytes - The binary content of the audio file.</li> <li><code>mimetype</code> str - The MIME type of the input file.</li> </ul> <p>Returns:</p> <ul> <li><code>Optional[bytes]</code> - The binary content of the converted audio file,   or None if the format is unsupported.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code> - If the requested format conversion is not supported.</li> </ul> <p></p>"},{"location":"memories-storage-docs/manager/#generate_waveform_thumbnail","title":"generate_waveform_thumbnail","text":"<pre><code>def generate_waveform_thumbnail(audio_path: Union[str, BytesIO],\n                                filetype: str) -&gt; Optional[BytesIO]\n</code></pre> <p>Generates a waveform thumbnail image from an audio file.</p> <p>Arguments:</p> <ul> <li><code>audio_path</code> Union[str, BytesIO] - Path to the audio file or BytesIO buffer.</li> <li><code>filetype</code> str - The format of the input audio file (e.g., 'mp3', 'wav').</li> </ul> <p>Returns:</p> <ul> <li><code>BytesIO</code> - A buffer containing the generated waveform image in PNG format.</li> </ul> <p></p>"},{"location":"memories-storage-docs/manager/#generate_spectrogram_thumbnail","title":"generate_spectrogram_thumbnail","text":"<pre><code>def generate_spectrogram_thumbnail(audio_path: Union[str, BytesIO],\n                                   filetype: str) -&gt; Optional[BytesIO]\n</code></pre> <p>Generates a spectrogram thumbnail image from an audio file.</p> <p>Arguments:</p> <ul> <li><code>audio_path</code> str - Path to the audio file.</li> </ul> <p>Returns:</p> <ul> <li><code>BytesIO</code> - A buffer containing the generated spectrogram image in PNG format.</li> </ul> <p></p>"},{"location":"memories-storage-docs/manager/#generate_piano_roll_thumbnail","title":"generate_piano_roll_thumbnail","text":"<pre><code>def generate_piano_roll_thumbnail(\n        midi_path: Union[str, BytesIO]) -&gt; Optional[BytesIO]\n</code></pre> <p>Generates a piano roll image from a MIDI file.</p> <p>Arguments:</p> <ul> <li><code>midi_path</code> Union[str, BytesIO] - Path or binary content of the MIDI file.</li> </ul> <p>Returns:</p> <ul> <li><code>BytesIO</code> - A buffer containing the piano roll image in PNG format.</li> </ul> <p></p>"},{"location":"memories-storage-docs/manager/#fetch_artwork","title":"fetch_artwork","text":"<pre><code>def fetch_artwork(album_name: str, artist_name: str) -&gt; Optional[BytesIO]\n</code></pre> <p>Fetches album artwork from iTunes or MusicBrainz and returns it as BytesIO.</p> <p></p>"},{"location":"memories-storage-docs/manager/#fetch_itunes_artwork","title":"fetch_itunes_artwork","text":"<pre><code>def fetch_itunes_artwork(album_name: str, artist_name: str) -&gt; Optional[str]\n</code></pre> <p>Fetches album artwork URL from iTunes API with dynamic resizing.</p> <p></p>"},{"location":"memories-storage-docs/manager/#fetch_musicbrainz_artwork","title":"fetch_musicbrainz_artwork","text":"<pre><code>def fetch_musicbrainz_artwork(album_name: str,\n                              artist_name: str) -&gt; Optional[str]\n</code></pre> <p>Fetches album artwork URL from MusicBrainz API.</p> <p></p>"},{"location":"memories-storage-docs/manager/#fetch_musicbrainz_release_id","title":"fetch_musicbrainz_release_id","text":"<pre><code>def fetch_musicbrainz_release_id(album_name: str,\n                                 artist_name: str) -&gt; Optional[str]\n</code></pre> <p>Fetches MBID from MusicBrainz API for the given album and artist.</p> <p></p>"},{"location":"memories-storage-docs/manager/#fetch_cover_art","title":"fetch_cover_art","text":"<pre><code>def fetch_cover_art(mbid: str) -&gt; Optional[str]\n</code></pre> <p>Fetches album artwork URL from Cover Art Archive.</p> <p></p>"},{"location":"memories-storage-docs/manager/#managervideo_processor","title":"manager.video_processor","text":""},{"location":"memories-storage-docs/manager/#videoprocessor-objects","title":"VideoProcessor Objects","text":"<pre><code>class VideoProcessor()\n</code></pre> <p>Class for processing video files, including format conversion.</p> <p></p>"},{"location":"memories-storage-docs/manager/#convert_video","title":"convert_video","text":"<pre><code>def convert_video(format: str, content: bytes, mimetype: str,\n                  output_resolution: str) -&gt; Optional[bytes]\n</code></pre> <p>Converts a video file to the specified format and resolution.</p> <p>Arguments:</p> <ul> <li><code>format</code> str - The target video format (e.g., 'mp4', 'avi').</li> <li><code>content</code> bytes - The binary content of the video file.</li> <li><code>mimetype</code> str - The MIME type of the input file.</li> <li><code>output_resolution</code> str - The desired resolution for the output video.</li> </ul> <p>Returns:</p> <ul> <li><code>Optional[bytes]</code> - The binary content of the converted video file,   or None if the format is unsupported.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code> - If the specified format is not supported for conversion.</li> <li><code>RuntimeError</code> - If the video conversion fails.</li> </ul> <p></p>"},{"location":"memories-storage-docs/manager/#managerdocument_processor","title":"manager.document_processor","text":""},{"location":"memories-storage-docs/manager/#documentprocessor-objects","title":"DocumentProcessor Objects","text":"<pre><code>class DocumentProcessor()\n</code></pre> <p>Handles document format conversions (PDF, EPUB, TXT, DOCX).</p> <p></p>"},{"location":"memories-storage-docs/manager/#convert_document","title":"convert_document","text":"<pre><code>def convert_document(format: str, content: bytes,\n                     mimetype: str) -&gt; Optional[bytes]\n</code></pre> <p>Converts a document to the specified format.</p> <p>Arguments:</p> <ul> <li><code>format</code> str - Target format ('txt', 'pdf', 'docx', 'epub').</li> <li><code>content</code> bytes - Raw document content.</li> <li><code>mimetype</code> str - MIME type of the document.</li> </ul> <p>Returns:</p> <ul> <li><code>Optional[bytes]</code> - Converted document content or None if unsupported format.</li> </ul> <p></p>"},{"location":"memories-storage-docs/manager/#convert_to_text","title":"convert_to_text","text":"<pre><code>def convert_to_text(content: bytes, mimetype: str) -&gt; bytes\n</code></pre> <p>Converts supported document formats into plain text using fitz (PyMuPDF).</p> <p>Arguments:</p> <ul> <li><code>content</code> bytes - Raw binary content of the document.</li> <li><code>mimetype</code> str - MIME type of the document.</li> </ul> <p>Returns:</p> <ul> <li><code>bytes</code> - Converted text content in UTF-8 encoding.</li> </ul> <p></p>"},{"location":"memories-storage-docs/manager/#convert_to_pdf","title":"convert_to_pdf","text":"<pre><code>def convert_to_pdf(content: bytes, mimetype: str) -&gt; bytes\n</code></pre> <p>Converts supported document formats into PDF using PyMuPDF.</p> <p>Arguments:</p> <ul> <li><code>content</code> bytes - Raw binary content of the document.</li> <li><code>mimetype</code> str - MIME type of the document.</li> </ul> <p>Returns:</p> <ul> <li><code>bytes</code> - Converted PDF content.</li> </ul> <p></p>"},{"location":"memories-storage-docs/manager/#convert_to_epub","title":"convert_to_epub","text":"<pre><code>def convert_to_epub(content: bytes, mimetype: str) -&gt; bytes\n</code></pre> <p>Converts the given document content into EPUB format.</p> <p>If the document is already EPUB, returns it unchanged. For other supported types, first converts to plain text and then creates an EPUB with a single chapter containing the text.</p> <p>Arguments:</p> <ul> <li><code>content</code> bytes - Raw binary content of the document.</li> <li><code>mimetype</code> str - MIME type of the document.</li> </ul> <p>Returns:</p> <ul> <li><code>bytes</code> - Converted EPUB content.</li> </ul> <p></p>"},{"location":"memories-storage-docs/manager/#convert_to_docx","title":"convert_to_docx","text":"<pre><code>def convert_to_docx(content: bytes, mimetype: str) -&gt; bytes\n</code></pre> <p>Converts supported document formats into DOCX using python-docx.</p> <p>If the document is already in DOCX (application/vnd.openxmlformats-officedocument.wordprocessingml.document or application/msword), returns it unchanged. For other supported formats, first converts to plain text then creates a DOCX with the text.</p> <p>Arguments:</p> <ul> <li><code>content</code> bytes - Raw binary content of the document.</li> <li><code>mimetype</code> str - MIME type of the document.</li> </ul> <p>Returns:</p> <ul> <li><code>bytes</code> - Converted DOCX content.</li> </ul> <p></p>"},{"location":"memories-storage-docs/manager/#managerresource_id_manager","title":"manager.resource_id_manager","text":""},{"location":"memories-storage-docs/manager/#resourceidmanager-objects","title":"ResourceIdManager Objects","text":"<pre><code>class ResourceIdManager()\n</code></pre> <p>Manages <code>resource_id</code> assignments for a given resource type. - Stores <code>resource_id</code> as a set for optimal lookups and modifications. - Provides a thread-safe structure using <code>threading.Lock</code>.</p> <p></p>"},{"location":"memories-storage-docs/manager/#__init__","title":"__init__","text":"<pre><code>def __init__(resource_name: str, storage_backend: AbstractStorageBackend)\n</code></pre> <p>Initializes the resource ID manager.</p> <p>Arguments:</p> <ul> <li><code>resource_name</code> str - The type of the resource (e.g., 'books', 'documents').</li> <li><code>storage_backend</code> AbstractStorageBackend - The backend used for storage operations.</li> </ul> <p></p>"},{"location":"memories-storage-docs/manager/#generate_resource_id","title":"generate_resource_id","text":"<pre><code>def generate_resource_id(user_id: str) -&gt; str\n</code></pre> <p>Generates a unique resource ID using UUID.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> </ul> <p>Returns:</p> <ul> <li><code>str</code> - A newly generated unique resource ID.</li> </ul> <p>Process:   1. Acquire thread lock for safe concurrent modifications.   2. Generate a new UUID-based resource ID.   3. Store the new resource ID in the set.   4. Return the newly created resource ID.</p> <p></p>"},{"location":"memories-storage-docs/manager/#release_resource_id","title":"release_resource_id","text":"<pre><code>def release_resource_id(user_id: str, resource_id: str) -&gt; None\n</code></pre> <p>Deletes a resource ID for a user.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> </ul> <p>Process:   1. Acquire thread lock for safe concurrent access.   2. Remove the specified <code>resource_id</code> from the set.</p> <p></p>"},{"location":"memories-storage-docs/manager/#get_resource_list","title":"get_resource_list","text":"<pre><code>def get_resource_list(user_id: str) -&gt; List[str]\n</code></pre> <p>Retrieves a list of resource IDs for a user.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resources.</li> </ul> <p>Returns:</p> <ul> <li><code>List[str]</code> - A list of resource IDs.</li> </ul> <p>Process:   1. Acquire thread lock for safe concurrent access.   2. Convert the stored set to a list before returning.</p> <p></p>"},{"location":"memories-storage-docs/manager/#count_resources","title":"count_resources","text":"<pre><code>def count_resources(user_id: str) -&gt; int\n</code></pre> <p>Returns the number of resources associated with a user.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user whose resources should be counted.</li> </ul> <p>Returns:</p> <ul> <li><code>int</code> - The number of resources available for the user.</li> </ul> <p>Process:   1. Acquire thread lock for safe concurrent access.   2. Return the length of the stored set.</p> <p></p>"},{"location":"memories-storage-docs/manager/#exist_resource","title":"exist_resource","text":"<pre><code>def exist_resource(user_id: str, resource_id: str) -&gt; bool\n</code></pre> <p>Checks if a resource ID exists for a user.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code> - <code>True</code> if the resource exists, <code>False</code> otherwise.</li> </ul> <p>Process:   1. Acquire thread lock for safe concurrent access.   2. Verify presence of the <code>resource_id</code> in the stored set.</p> <p></p>"},{"location":"memories-storage-docs/manager/#managercontent_id_manager","title":"manager.content_id_manager","text":""},{"location":"memories-storage-docs/manager/#contentidmanager-objects","title":"ContentIdManager Objects","text":"<pre><code>class ContentIdManager()\n</code></pre> <p>Manages <code>content_id</code> assignments for a given resource type. - Maintains a persistent set of content IDs per user and resource. - Ensures thread-safe operations using <code>threading.Lock</code>.</p> <p></p>"},{"location":"memories-storage-docs/manager/#__init___1","title":"__init__","text":"<pre><code>def __init__(resource_name: str, storage_backend: AbstractStorageBackend)\n</code></pre> <p>Initializes the content ID manager.</p> <p>Arguments:</p> <ul> <li><code>resource_name</code> str - The type of the resource (e.g., 'books', 'documents').</li> <li><code>storage_backend</code> AbstractStorageBackend - The backend used for storage operations.</li> </ul> <p></p>"},{"location":"memories-storage-docs/manager/#generate_content_id","title":"generate_content_id","text":"<pre><code>def generate_content_id(user_id: str, resource_id: str) -&gt; int\n</code></pre> <p>Generates the next available <code>content_id</code> within a resource.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> </ul> <p>Returns:</p> <ul> <li><code>int</code> - The next available <code>content_id</code>.</li> </ul> <p>Process:   1. Acquire thread lock for safe concurrent access.   2. Load existing IDs and determine the next available ID.   3. Prioritize IDs from <code>1</code> to <code>9</code>, then find the lowest unused integer.   4. Add the assigned <code>content_id</code> to the set and return it.</p> <p></p>"},{"location":"memories-storage-docs/manager/#release_content_id","title":"release_content_id","text":"<pre><code>def release_content_id(user_id: str, resource_id: str, content_id: int)\n</code></pre> <p>Releases a <code>content_id</code> when content is deleted.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> <li><code>content_id</code> int - The content ID to be released.</li> </ul> <p>Process:   1. Acquire thread lock for safe concurrent modifications.   2. Remove the specified <code>content_id</code> from the active set.</p> <p></p>"},{"location":"memories-storage-docs/manager/#exist_content","title":"exist_content","text":"<pre><code>def exist_content(user_id: str, resource_id: str, content_id: int) -&gt; bool\n</code></pre> <p>Checks if a <code>content_id</code> exists for a given resource.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> <li><code>content_id</code> int - The content ID to check.</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code> - <code>True</code> if the content exists, <code>False</code> otherwise.</li> </ul> <p>Process:   1. Acquire thread lock for safe concurrent access.   2. Verify if the <code>content_id</code> is present in the active set.</p> <p></p>"},{"location":"memories-storage-docs/manager/#get_content_list","title":"get_content_list","text":"<pre><code>def get_content_list(user_id: str, resource_id: str) -&gt; list\n</code></pre> <p>Retrieves all <code>content_ids</code> for a specified resource.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> </ul> <p>Returns:</p> <ul> <li><code>list</code> - A list of all <code>content_ids</code> associated with the resource.</li> </ul> <p>Process:   1. Acquire thread lock to ensure thread-safe access.   2. Initialize the content ID set if not already loaded.   3. Retrieve and return the list of <code>content_ids</code>.</p>"},{"location":"memories-storage-docs/models/","title":"Models","text":""},{"location":"memories-storage-docs/models/#models","title":"models","text":""},{"location":"memories-storage-docs/models/#modelstypes","title":"models.types","text":""},{"location":"memories-storage-docs/models/#extrainfo-objects","title":"ExtraInfo Objects","text":"<pre><code>class ExtraInfo(TypedDict)\n</code></pre>"},{"location":"memories-storage-docs/models/#exif","title":"exif","text":"<p>File information obtainable with exiftools</p> <p></p>"},{"location":"memories-storage-docs/models/#location","title":"location","text":"<p>Geolocation information</p> <p></p>"},{"location":"memories-storage-docs/models/#contentmeta-objects","title":"ContentMeta Objects","text":"<pre><code>class ContentMeta(TypedDict)\n</code></pre> <p>Defines metadata related to a content resource.</p> <p></p>"},{"location":"memories-storage-docs/models/#id","title":"id","text":"<p>Unique identifier of the content</p> <p></p>"},{"location":"memories-storage-docs/models/#filename","title":"filename","text":"<p>Name of the file</p> <p></p>"},{"location":"memories-storage-docs/models/#mimetype","title":"mimetype","text":"<p>MIME type of the content</p> <p></p>"},{"location":"memories-storage-docs/models/#hash","title":"hash","text":"<p>Hash of the content for integrity validation</p> <p></p>"},{"location":"memories-storage-docs/models/#size","title":"size","text":"<p>Size of the content in bytes</p> <p></p>"},{"location":"memories-storage-docs/models/#created_at","title":"created_at","text":"<p>Timestamp when the content was created (ISO 8601 format)</p> <p></p>"},{"location":"memories-storage-docs/models/#updated_at","title":"updated_at","text":"<p>Timestamp when the content was last updated (ISO 8601 format)</p> <p></p>"},{"location":"memories-storage-docs/models/#extra_info","title":"extra_info","text":"<p>Additional metadata specific to the content</p> <p></p>"},{"location":"memories-storage-docs/models/#basicmeta-objects","title":"BasicMeta Objects","text":"<pre><code>class BasicMeta(TypedDict)\n</code></pre> <p>Represents the fundamental metadata common to all resource types.</p> <p></p>"},{"location":"memories-storage-docs/models/#created_at_1","title":"created_at","text":"<p>Timestamp when the resource was created (ISO 8601 format)</p> <p></p>"},{"location":"memories-storage-docs/models/#updated_at_1","title":"updated_at","text":"<p>Timestamp when the resource was last updated (ISO 8601 format)</p> <p></p>"},{"location":"memories-storage-docs/models/#content_ids","title":"content_ids","text":"<p>List of associated content IDs</p> <p></p>"},{"location":"memories-storage-docs/models/#contents","title":"contents","text":"<p>List of content metadata associated with the resource</p> <p></p>"},{"location":"memories-storage-docs/models/#extra_info_1","title":"extra_info","text":"<p>Resource-specific additional metadata</p> <p></p>"},{"location":"memories-storage-docs/models/#child_resource_ids","title":"child_resource_ids","text":"<p>Nested resources within a resource</p> <p></p>"},{"location":"memories-storage-docs/models/#parent_resource_ids","title":"parent_resource_ids","text":"<p>Parent resources</p> <p></p>"},{"location":"memories-storage-docs/models/#detailmeta-objects","title":"DetailMeta Objects","text":"<pre><code>class DetailMeta(TypedDict)\n</code></pre> <p>User-defined metadata that allows flexible extensions for different use cases.</p> <p></p>"},{"location":"memories-storage-docs/models/#metadata","title":"metadata","text":"<p>Arbitrary user-defined metadata</p> <p></p>"},{"location":"memories-storage-docs/models/#resourcemeta-objects","title":"ResourceMeta Objects","text":"<pre><code>class ResourceMeta(TypedDict)\n</code></pre> <p>Aggregates metadata related to a resource, including basic and detailed metadata.</p> <p></p>"},{"location":"memories-storage-docs/models/#basic_meta","title":"basic_meta","text":"<p>Fundamental metadata shared across resource types</p> <p></p>"},{"location":"memories-storage-docs/models/#detail_meta","title":"detail_meta","text":"<p>Resource-specific detailed metadata</p>"},{"location":"memories-storage-docs/services/","title":"Services","text":""},{"location":"memories-storage-docs/services/#services","title":"services","text":""},{"location":"memories-storage-docs/services/#servicesbook_service","title":"services.book_service","text":""},{"location":"memories-storage-docs/services/#bookservice-objects","title":"BookService Objects","text":"<pre><code>class BookService(BaseService)\n</code></pre> <p>Service for handling book-related resources, including thumbnail processing.</p> <p></p>"},{"location":"memories-storage-docs/services/#__init__","title":"__init__","text":"<pre><code>def __init__(storage_backend)\n</code></pre> <p>Initializes the BookService with a specified storage backend.</p> <p>Arguments:</p> <ul> <li><code>storage_backend</code> - The backend used for storing book resources.</li> </ul> <p></p>"},{"location":"memories-storage-docs/services/#servicesbase_service","title":"services.base_service","text":""},{"location":"memories-storage-docs/services/#baseservice-objects","title":"BaseService Objects","text":"<pre><code>class BaseService()\n</code></pre> <p>BaseService class for managing resources and their metadata. This class provides methods for creating, updating, and retrieving resources, as well as handling content and thumbnail generation.</p> <p></p>"},{"location":"memories-storage-docs/services/#__init___1","title":"__init__","text":"<pre><code>def __init__(storage_backend: AbstractStorageBackend, resource_name: str)\n</code></pre> <p>Initializes the BaseService with a storage backend and resource name.</p> <p>Arguments:</p> <ul> <li><code>storage_backend</code> AbstractStorageBackend - The storage backend for resource management.</li> <li><code>resource_name</code> str - The name of the resource type.</li> </ul> <p></p>"},{"location":"memories-storage-docs/services/#get_resource_ids","title":"get_resource_ids","text":"<pre><code>def get_resource_ids() -&gt; Response\n</code></pre> <p>Retrieves a list of resource IDs for the authenticated user.</p> <p>Arguments:</p> <p>None (uses authenticated user context).</p> <p>Returns:</p> <ul> <li><code>Response</code> - A JSON response containing resource IDs.</li> </ul> <p></p>"},{"location":"memories-storage-docs/services/#get_resource_list","title":"get_resource_list","text":"<pre><code>def get_resource_list() -&gt; Response\n</code></pre> <p>[GET] /RESOURCE_TYPE/ Retrieves a list of resource IDs belonging to the authenticated user. If pagination (<code>page</code> and <code>per_page</code>) is specified, returns a paginated response.</p> <p>Arguments:</p> <p>None (uses authenticated user context).</p> <p>Query Parameters: - <code>page</code> int, optional - The page number for pagination. - <code>per_page</code> int, optional - The number of resources per page.</p> <p>Returns:</p> <ul> <li><code>Response</code> - A JSON response containing resource IDs and pagination details.</li> </ul> <p>Process:   1. Retrieve total number of resources and resource list.   2. Apply pagination if <code>page</code> and <code>per_page</code> are provided.   3. Return a structured response with paginated resource IDs.</p> <p>Response Structure:   { - <code>\"status\"</code> - \"success\", - <code>\"message\"</code> - \"Resource list retrieved successfully.\", - <code>\"response_data\"</code> - { - <code>\"resources\"</code> - [], - <code>\"total_items\"</code> - , - <code>\"page\"</code> - , - <code>\"per_page\"</code> -    }   } <p></p>"},{"location":"memories-storage-docs/services/#get_content_list","title":"get_content_list","text":"<pre><code>def get_content_list(resource_id: str) -&gt; Response\n</code></pre> <p>Retrieves the list of content IDs and metadata associated with a specific resource.</p> <p>Arguments:</p> <ul> <li><code>resource_id</code> str - The unique identifier for the resource.</li> </ul> <p>Returns:</p> <ul> <li><code>Response</code> - A JSON response containing content IDs and metadata.</li> </ul> <p>Process:   1. Validate the resource ID.   2. Retrieve associated content IDs from the content manager.   3. Load resource metadata from storage backend.   4. Return a structured response containing <code>content_ids</code> and <code>contents</code>.</p> <p>Response Structure:</p> <pre><code>{\n    \"status\": \"success\",\n    \"message\": \"Content list for resource retrieved successfully.\",\n    \"resource_id\": \"&lt;str&gt;\",\n    \"response_data\": {\n        \"content_ids\": [1, 2, ...],\n        \"contents\": [{ \"id\": &lt;int&gt;, \"filename\": \"&lt;str&gt;\", \"mimetype\": \"&lt;str&gt;\", \"hash\": \"&lt;str&gt;\" }, ...]\n    }\n}\n</code></pre> <p></p>"},{"location":"memories-storage-docs/services/#make_resource","title":"make_resource","text":"<pre><code>def make_resource(resource_component: Optional[str] = None) -&gt; Response\n</code></pre> <p>[POST] /RESOURCE_TYPE/ Creates a new resource. Accepts metadata via 'detail-file' and/or content via 'content-file'. The 'resource_component' parameter can specify if only metadata or content is being uploaded.</p> <p>Arguments:</p> <ul> <li><code>resource_component</code> Optional[str] - Specifies if \"meta\" (metadata-only) or \"content\" (content-only) is being uploaded. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li><code>Response</code> - A JSON response indicating the success or failure of the resource creation.</li> </ul> <p>Process:   1. Validate input files (metadata and/or content).   2. Generate resource ID if needed.   3. Process content file (generate content ID, compute hash, and validate format).   4. Structure metadata using <code>_make_resource_meta()</code>.   5. Save resource and return a success or error response.</p> <p>Response Structure:   { - <code>\"status\"</code> - \"success\", - <code>\"message\"</code> - \"Resource added successfully.\", - <code>\"resource_id\"</code> - \"\", - <code>\"content_id\"</code> - \"\",   } <p></p>"},{"location":"memories-storage-docs/services/#post_resource_content_addition","title":"post_resource_content_addition","text":"<pre><code>def post_resource_content_addition(resource_id: str) -&gt; Response\n</code></pre> <p>[POST] /RESOURCE_TYPE//content Adds new content to an existing resource while ensuring that duplicate content is not stored. Content will only be added if its hash differs from any existing content, preventing redundancy. <p>Arguments:</p> <ul> <li><code>resource_id</code> str - The ID of the resource to which the content will be added.</li> </ul> <p>Returns:</p> <ul> <li><code>Response</code> - A JSON response indicating success or failure.</li> </ul> <p>Process:   1. Validate resource ID and content file.   2. Retrieve existing resource metadata.   3. Compute hash of the new content.   4. Check for duplicate content (same hash, regardless of extension).   5. If unique, generate a new content ID and update metadata.   6. Save updated resource metadata and content file.   7. Return a success or error response.</p> <p>Response Structure:   { - <code>\"status\"</code> - \"success\", - <code>\"message\"</code> - \"New content added successfully.\", - <code>\"resource_id\"</code> - \"\", - <code>\"content_id\"</code> - \"\",   } <p></p>"},{"location":"memories-storage-docs/services/#get_resource_meta","title":"get_resource_meta","text":"<pre><code>def get_resource_meta(resource_id: str) -&gt; Response\n</code></pre> <p>[GET] /RESOURCE_TYPE//meta Retrieves metadata for a specific resource, including system-managed (<code>basic_meta</code>) and user-editable (<code>detail_meta</code>) data. <p>Arguments:</p> <ul> <li><code>resource_id</code> str - The ID of the resource whose metadata is being retrieved.</li> </ul> <p>Returns:</p> <ul> <li><code>Response</code> - A JSON response containing the requested resource metadata.</li> </ul> <p>Process:   1. Validate resource ID.   2. Retrieve metadata from the storage backend.   3. Return a response with <code>basic_meta</code> and <code>detail_meta</code>.</p> <p>Response Structure:   { - <code>\"status\"</code> - \"success\", - <code>\"message\"</code> - \"Metadata retrieved successfully.\", - <code>\"resource_id\"</code> - \"\", - <code>\"basic_meta\"</code> - { ... }, - <code>\"detail_meta\"</code> - { ... }   } <p></p>"},{"location":"memories-storage-docs/services/#get_resource_content","title":"get_resource_content","text":"<pre><code>def get_resource_content(resource_id: str,\n                         content_id: int,\n                         filename: Optional[str] = None) -&gt; Response\n</code></pre> <p>[GET] /RESOURCE_TYPE//content/ Retrieves content for a specific resource by <code>content_id</code>. <code>extension</code>-based searches have been removed, and MIME type (<code>mimetype</code>) is now used for format management. <p>Arguments:</p> <ul> <li><code>resource_id</code> str - The ID of the resource whose content is being retrieved.</li> <li><code>content_id</code> int - The unique ID of the content associated with the resource.</li> </ul> <p>Query Parameters: - <code>binary</code> bool, optional - If true, returns raw binary data instead of a base64-encoded string.</p> <p>Returns:</p> <ul> <li><code>Response</code> - Either a JSON response containing a base64-encoded content or raw binary data.</li> </ul> <p>Process:   1. Validate resource ID and content ID.   2. Retrieve content from the storage backend.   3. Fetch resource metadata and verify <code>content_id</code> exists.   4. Retrieve the MIME type (<code>mimetype</code>) of the content.   5. Apply optional content conversion.   6. If binary mode is requested, return raw binary data.   7. Otherwise, encode content in base64 and return a JSON response.</p> <p>Response Structure (base64-encoded content):   { - <code>\"status\"</code> - \"success\", - <code>\"message\"</code> - \"Resource content retrieved successfully.\", - <code>\"resource_id\"</code> - \"\", - <code>\"content_id\"</code> - \"\", - <code>\"response_data\"</code> - { - <code>\"content\"</code> - \"\", - <code>\"mimetype\"</code> - \"\"   }   } <p></p>"},{"location":"memories-storage-docs/services/#get_resource_thumbnail","title":"get_resource_thumbnail","text":"<pre><code>def get_resource_thumbnail(resource_id: str) -&gt; Response\n</code></pre> <p>[GET] /RESOURCE_TYPE//thumbnail Retrieves the thumbnail for a specific resource. <p>Arguments:</p> <ul> <li><code>resource_id</code> str - The ID of the resource whose thumbnail is being retrieved.</li> </ul> <p>Query Parameters: - <code>thumbnail_size</code> str, optional - Specifies the size of the thumbnail. Defaults to \"medium\".   Available sizes: [\"original\", \"small\", \"medium\", \"large\"]. - <code>binary</code> bool, optional - If true, returns raw binary data instead of a base64-encoded string.</p> <p>Returns:</p> <ul> <li><code>Response</code> - Either a JSON response containing a base64-encoded thumbnail or raw binary data.</li> </ul> <p>Process:   1. Validate resource ID.   2. Parse query parameters (<code>thumbnail_size</code> and <code>binary</code>).   3. Retrieve the requested thumbnail from the storage backend.   4. If binary mode is requested, return raw binary data.   5. Otherwise, encode thumbnail in base64 and return a JSON response.</p> <p>Response Structure (base64-encoded thumbnail):   { - <code>\"status\"</code> - \"success\", - <code>\"message\"</code> - \"Thumbnail retrieved successfully.\", - <code>\"resource_id\"</code> - \"\", - <code>\"response_data\"</code> - { - <code>\"thumbnail\"</code> - \"\"   }   } <p></p>"},{"location":"memories-storage-docs/services/#put_resource_detail","title":"put_resource_detail","text":"<pre><code>def put_resource_detail(resource_id: str) -&gt; Response\n</code></pre> <p>[PUT] /RESOURCE_TYPE//detail Updates only the <code>detail_meta</code> for an existing resource. <p>Arguments:</p> <ul> <li><code>resource_id</code> str - The ID of the resource whose metadata is being updated.</li> </ul> <p>Request:   - Requires a JSON file (<code>detail-file</code>) containing the updated metadata.</p> <p>Returns:</p> <ul> <li><code>Response</code> - A JSON response indicating success or failure.</li> </ul> <p>Process:   1. Validate resource ID and check for <code>detail-file</code>.   2. Parse and validate the JSON metadata.   3. Update only <code>detail_meta</code>, ensuring <code>basic_meta</code> remains unchanged.   4. Save the updated resource metadata to storage.   5. Return a success or error response.</p> <p>Response Structure:   { - <code>\"status\"</code> - \"success\", - <code>\"message\"</code> - \"Details updated successfully.\", - <code>\"resource_id\"</code> - \"\",   } <p></p>"},{"location":"memories-storage-docs/services/#put_resource_content","title":"put_resource_content","text":"<pre><code>def put_resource_content(resource_id: str, content_id: int) -&gt; Response\n</code></pre> <p>[PUT] /RESOURCE_TYPE//content/ Updates existing content in a resource while ensuring that identical content does not get duplicated. <p>Arguments:</p> <ul> <li><code>resource_id</code> str - The ID of the resource whose content is being updated.</li> <li><code>content_id</code> int - The ID of the content within the resource.</li> </ul> <p>Request:   - Requires a content file (<code>content-file</code>) for updating the content.   - Optional: <code>generate-thumbnail=true</code> triggers thumbnail generation.</p> <p>Returns:</p> <ul> <li><code>Response</code> - A JSON response indicating success or failure.</li> </ul> <p>Process:   1. Validate resource ID and content ID.   2. Ensure the resource and content exist.   3. Validate and process uploaded content.   4. Check for duplicate content by comparing hashes.   5. Update resource metadata and prevent redundant storage.   6. Save updated resource and return a success response.</p> <p>Response Structure:   { - <code>\"status\"</code> - \"success\", - <code>\"message\"</code> - \"Content updated successfully.\", - <code>\"resource_id\"</code> - \"\", - <code>\"content_id\"</code> - \"\",   } <p></p>"},{"location":"memories-storage-docs/services/#put_resource_thumbnail","title":"put_resource_thumbnail","text":"<pre><code>def put_resource_thumbnail(resource_id: str) -&gt; Response\n</code></pre> <p>[PUT] /RESOURCE_TYPE//thumbnail Updates the thumbnail for an existing resource without modifying its metadata or content. <p>Arguments:</p> <ul> <li><code>resource_id</code> str - The ID of the resource whose thumbnail is being updated.</li> </ul> <p>Request:   - Requires an image file (<code>thumbnail-file</code>) for updating the thumbnail.</p> <p>Returns:</p> <ul> <li><code>Response</code> - A JSON response indicating success or failure.</li> </ul> <p>Process:   1. Validate resource ID.   2. Validate and process uploaded thumbnail file.   3. Apply content validation (<code>_validate_content_format()</code>).   4. Save updated thumbnail while preserving existing metadata and content.   5. Return a success or error response.</p> <p>Response Structure:   { - <code>\"status\"</code> - \"success\", - <code>\"message\"</code> - \"Thumbnail updated successfully.\", - <code>\"resource_id\"</code> - \"\",   } <p></p>"},{"location":"memories-storage-docs/services/#patch_resource_thumbnail","title":"patch_resource_thumbnail","text":"<pre><code>def patch_resource_thumbnail(resource_id: str) -&gt; Response\n</code></pre> <p>[PATCH] /RESOURCE_TYPE//thumbnail Rotates an existing resource thumbnail by a specified angle. <p>Arguments:</p> <ul> <li><code>resource_id</code> str - The ID of the resource whose thumbnail needs rotation.</li> </ul> <p>Returns:</p> <ul> <li><code>Response</code> - <code>HTTPStatus.OK</code> if the rotation is successful, or an error response.</li> </ul> <p>Process:   1. Validate resource ID.   2. Ensure the resource exists and has an original thumbnail.   3. Retrieve and validate the angle parameter.   4. Rotate the thumbnail image.   5. Save the updated thumbnail.   6. Return a <code>HTTPStatus.OK</code> response if rotation is successful.</p> <p>Response Structure:   - Success: <code>HTTPStatus.OK</code>   - Failure: JSON response with error details.</p> <p></p>"},{"location":"memories-storage-docs/services/#delete_resource","title":"delete_resource","text":"<pre><code>def delete_resource(resource_id: str) -&gt; Response\n</code></pre> <p>[DELETE] /RESOURCE_TYPE/ Deletes an existing resource and removes its metadata and content. <p>Arguments:</p> <ul> <li><code>resource_id</code> str - The ID of the resource to delete.</li> </ul> <p>Returns:</p> <ul> <li><code>Response</code> - <code>HTTPStatus.NO_CONTENT</code> if deletion is successful, or an error response.</li> </ul> <p>Process:   1. Validate resource ID.   2. Ensure the resource exists.   3. Execute resource deletion.   4. Release the resource ID from resource management.   5. Return a <code>HTTPStatus.NO_CONTENT</code> response if deletion is successful.</p> <p>Response Structure:   - Success: <code>HTTPStatus.NO_CONTENT</code>   - Failure: JSON response with error details.</p> <p></p>"},{"location":"memories-storage-docs/services/#delete_resource_content","title":"delete_resource_content","text":"<pre><code>def delete_resource_content(resource_id: str, content_id: int) -&gt; Response\n</code></pre> <p>[DELETE] /RESOURCE_TYPE//content/ Deletes a specific content item from a resource without affecting metadata or thumbnails. <p>Arguments:</p> <ul> <li><code>resource_id</code> str - The ID of the resource from which content will be deleted.</li> <li><code>content_id</code> int - The unique ID of the content item to be deleted.</li> </ul> <p>Returns:</p> <ul> <li><code>Response</code> - <code>HTTPStatus.NO_CONTENT</code> if deletion is successful, or an error response.</li> </ul> <p>Process:   1. Validate resource ID and content ID.   2. Remove the content from metadata and update <code>basic_meta</code>.   3. Save updated metadata after deletion.   4. Delete the actual content from storage.   5. Return <code>HTTPStatus.NO_CONTENT</code> if deletion is successful.</p> <p>Response Structure:   - Success: <code>HTTPStatus.NO_CONTENT</code>   - Failure: JSON response with error details.</p> <p></p>"},{"location":"memories-storage-docs/services/#servicesmusic_service","title":"services.music_service","text":""},{"location":"memories-storage-docs/services/#servicesinit","title":"services.init","text":""},{"location":"memories-storage-docs/services/#servicesdocument_service","title":"services.document_service","text":""},{"location":"memories-storage-docs/services/#servicesimage_service","title":"services.image_service","text":""},{"location":"memories-storage-docs/services/#servicesvideo_service","title":"services.video_service","text":""},{"location":"memories-storage-docs/storage/","title":"Storage","text":""},{"location":"memories-storage-docs/storage/#storage","title":"storage","text":""},{"location":"memories-storage-docs/storage/#storageabstract_backend","title":"storage.abstract_backend","text":""},{"location":"memories-storage-docs/storage/#abstractstoragebackend-objects","title":"AbstractStorageBackend Objects","text":"<pre><code>class AbstractStorageBackend(ABC)\n</code></pre>"},{"location":"memories-storage-docs/storage/#get_resource_list","title":"get_resource_list","text":"<pre><code>@abstractmethod\ndef get_resource_list(user_id: str, resource_type: str) -&gt; List[str]\n</code></pre> <p>Retrieves a list of resource IDs for a given user and resource type.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resources.</li> <li><code>resource_type</code> str - The type of the resource (e.g., 'books', 'documents').</li> </ul> <p>Returns:</p> <ul> <li><code>List[str]</code> - A list of resource IDs found within the specified resource type.</li> </ul> <p>Process:   1. Determine the directory for the specified <code>resource_type</code>.   2. Verify if the directory exists. If not, return an empty list.   3. Traverse the directory structure to locate resources.   4. Identify directories containing <code>metadata.json</code>, extract their names as <code>resource_id</code>.   5. Return the collected resource IDs.</p> <p></p>"},{"location":"memories-storage-docs/storage/#load_resource_meta","title":"load_resource_meta","text":"<pre><code>@abstractmethod\ndef load_resource_meta(user_id: str, resource_type: str,\n                       resource_id: str) -&gt; Optional[ResourceMeta]\n</code></pre> <p>Load the metadata for the specified resource.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_type</code> str - The type of the resource (e.g., 'image', 'video').</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> </ul> <p>Returns:</p> <ul> <li><code>Optional[dict]</code> - The metadata dictionary if the file exists, otherwise None.</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code> - If an error occurs while reading or parsing the metadata file.</li> </ul> <p></p>"},{"location":"memories-storage-docs/storage/#load_resource_content","title":"load_resource_content","text":"<pre><code>@abstractmethod\ndef load_resource_content(user_id: str, resource_type: str, resource_id: str,\n                          content_id: int) -&gt; Optional[bytes]\n</code></pre> <p>Loads the content file for a specified resource.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_type</code> str - The type of the resource (e.g., 'books', 'documents').</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> <li><code>content_id</code> int - The unique identifier of the content.</li> </ul> <p>Returns:</p> <ul> <li><code>Optional[bytes]</code> - Raw binary content if the file exists, otherwise <code>None</code>.</li> </ul> <p>Process:   1. Construct the content file path using provided <code>content_id</code>.   2. Check if the file exists before attempting to load.   3. Load and return the content file, or log an error if retrieval fails.</p> <p></p>"},{"location":"memories-storage-docs/storage/#load_resource_thumbnail","title":"load_resource_thumbnail","text":"<pre><code>@abstractmethod\ndef load_resource_thumbnail(user_id: str, resource_type: str, resource_id: str,\n                            thumbnail_size: str) -&gt; Optional[bytes]\n</code></pre> <p>Loads the thumbnail image for a specified resource.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_type</code> str - The type of the resource (e.g., 'books', 'documents').</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> <li><code>thumbnail_size</code> str - The requested thumbnail size ('original', 'small', 'medium', 'large').</li> </ul> <p>Returns:</p> <ul> <li><code>Optional[bytes]</code> - Raw binary content if the thumbnail exists, otherwise <code>None</code>.</li> </ul> <p>Process:   1. Determine the correct thumbnail file path based on <code>thumbnail_size</code>.   2. Validate if the requested size is supported (<code>original</code>, <code>small</code>, <code>medium</code>, <code>large</code>).   3. Check if the thumbnail file exists before attempting to load.   4. Load and return the thumbnail file, or log an error if retrieval fails.</p> <p></p>"},{"location":"memories-storage-docs/storage/#save_resource","title":"save_resource","text":"<pre><code>@abstractmethod\ndef save_resource(user_id: str,\n                  resource_type: str,\n                  resource_id: str,\n                  metadata: Optional[ResourceMeta] = None,\n                  content_file: Optional[BytesIO] = None,\n                  content_id: Optional[int] = None,\n                  thumbnail_file: Optional[BytesIO] = None) -&gt; Optional[str]\n</code></pre> <p>Saves a resource by storing its metadata, content, and optional thumbnail.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_type</code> str - The type of the resource (e.g., 'books', 'documents').</li> <li><code>resource_id</code> str - A unique identifier for the resource.</li> <li><code>metadata</code> Optional[dict] - Structured metadata for the resource.</li> <li><code>content_file</code> Optional[BytesIO] - The content file as a BytesIO object.</li> <li><code>content_id</code> Optional[int] - The ID of the content.</li> <li><code>thumbnail_file</code> Optional[BytesIO] - Optional thumbnail image.</li> </ul> <p>Returns:</p> <ul> <li><code>Optional[str]</code> - The directory path where the resource was saved, or <code>None</code> if saving failed.</li> </ul> <p>Process:   1. Ensure the resource directory exists.   2. Save metadata, content, and optional thumbnails using parallel threads.   3. Validate storage success and handle errors gracefully.</p> <p></p>"},{"location":"memories-storage-docs/storage/#save_resource_meta","title":"save_resource_meta","text":"<pre><code>@abstractmethod\ndef save_resource_meta(user_id: str, resource_type: str, resource_id: str,\n                       metadata: ResourceMeta) -&gt; str\n</code></pre> <p>Saves resource metadata using the primary <code>save_resource</code> method.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_type</code> str - The type of the resource (e.g., 'books', 'documents').</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> <li><code>metadata</code> dict - Metadata information to be saved.</li> </ul> <p>Returns:</p> <ul> <li><code>Optional[str]</code> - The directory path where the metadata was saved, or <code>None</code> if saving failed.</li> </ul> <p>Process:   1. Calls <code>save_resource()</code> with metadata to store it appropriately.   2. Returns the directory path of the saved resource metadata.</p> <p></p>"},{"location":"memories-storage-docs/storage/#delete_resource","title":"delete_resource","text":"<pre><code>@abstractmethod\ndef delete_resource(user_id: str, resource_type: str,\n                    resource_id: str) -&gt; bool\n</code></pre> <p>Deletes the specified resource and its associated directory.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_type</code> str - The type of the resource (e.g., 'books', 'documents').</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code> - <code>True</code> if the resource was successfully deleted, <code>False</code> otherwise.</li> </ul> <p>Process:   1. Determine the resource directory path.   2. Verify if the directory exists. If not, log a warning and return <code>False</code>.   3. Attempt to delete the directory and its contents.   4. Log success if deletion is successful, otherwise log the exception.</p> <p></p>"},{"location":"memories-storage-docs/storage/#delete_resource_content","title":"delete_resource_content","text":"<pre><code>@abstractmethod\ndef delete_resource_content(user_id: str, resource_type: str, resource_id: str,\n                            content_id: int) -&gt; bool\n</code></pre> <p>Deletes the specified content from the given resource.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_type</code> str - The type of the resource (e.g., 'books', 'documents').</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> <li><code>content_id</code> int - The unique identifier for the content to be deleted.</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code> - <code>True</code> if the content was successfully deleted, <code>False</code> otherwise.</li> </ul> <p>Process:   1. Determine the resource directory path.   2. Verify if the directory exists. If not, log a warning and return <code>False</code>.   3. Identify matching content files using wildcard search.   4. If no matching files are found, log a warning and return <code>False</code>.   5. Delete each matching file and log the deletion status.   6. Return <code>True</code> upon successful deletion.</p> <p></p>"},{"location":"memories-storage-docs/storage/#storagelocal_bare_backend","title":"storage.local_bare_backend","text":""},{"location":"memories-storage-docs/storage/#localstoragebarebackend-objects","title":"LocalStorageBareBackend Objects","text":"<pre><code>class LocalStorageBareBackend(AbstractStorageBackend)\n</code></pre>"},{"location":"memories-storage-docs/storage/#get_resource_list_1","title":"get_resource_list","text":"<pre><code>def get_resource_list(user_id: str, resource_type: str) -&gt; List[str]\n</code></pre> <p>Retrieves a list of resource IDs for a given user and resource type.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resources.</li> <li><code>resource_type</code> str - The type of the resource (e.g., 'books', 'documents').</li> </ul> <p>Returns:</p> <ul> <li><code>List[str]</code> - A list of resource IDs found within the specified resource type.</li> </ul> <p>Process:   1. Determine the directory for the specified <code>resource_type</code>.   2. Verify if the directory exists. If not, return an empty list.   3. Traverse the directory structure to locate resources.   4. Identify directories containing <code>metadata.json</code>, extract their names as <code>resource_id</code>.   5. Return the collected resource IDs.</p> <p></p>"},{"location":"memories-storage-docs/storage/#load_resource_meta_1","title":"load_resource_meta","text":"<pre><code>def load_resource_meta(user_id: str, resource_type: str,\n                       resource_id: str) -&gt; Optional[dict]\n</code></pre> <p>Load the metadata for the specified resource.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_type</code> str - The type of the resource (e.g., 'image', 'video').</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> </ul> <p>Returns:</p> <ul> <li><code>Optional[dict]</code> - The metadata dictionary if the file exists, otherwise None.</li> </ul> <p>Raises:</p> <ul> <li><code>RuntimeError</code> - If an error occurs while reading or parsing the metadata file.</li> </ul> <p></p>"},{"location":"memories-storage-docs/storage/#load_resource_content_1","title":"load_resource_content","text":"<pre><code>def load_resource_content(user_id: str, resource_type: str, resource_id: str,\n                          content_id: int) -&gt; Optional[bytes]\n</code></pre> <p>Loads the content file for a specified resource.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_type</code> str - The type of the resource (e.g., 'books', 'documents').</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> <li><code>content_id</code> int - The unique identifier of the content.</li> </ul> <p>Returns:</p> <ul> <li><code>Optional[bytes]</code> - Raw binary content if the file exists, otherwise <code>None</code>.</li> </ul> <p>Process:   1. Construct the content file path using provided <code>content_id</code>.   2. Check if the file exists before attempting to load.   3. Load and return the content file, or log an error if retrieval fails.</p> <p></p>"},{"location":"memories-storage-docs/storage/#load_resource_thumbnail_1","title":"load_resource_thumbnail","text":"<pre><code>def load_resource_thumbnail(user_id: str, resource_type: str, resource_id: str,\n                            thumbnail_size: str) -&gt; Optional[bytes]\n</code></pre> <p>Loads the thumbnail image for a specified resource.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_type</code> str - The type of the resource (e.g., 'books', 'documents').</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> <li><code>thumbnail_size</code> str - The requested thumbnail size ('original', 'small', 'medium', 'large').</li> </ul> <p>Returns:</p> <ul> <li><code>Optional[bytes]</code> - Raw binary content if the thumbnail exists, otherwise <code>None</code>.</li> </ul> <p>Process:   1. Determine the correct thumbnail file path based on <code>thumbnail_size</code>.   2. Validate if the requested size is supported (<code>original</code>, <code>small</code>, <code>medium</code>, <code>large</code>).   3. Check if the thumbnail file exists before attempting to load.   4. Load and return the thumbnail file, or log an error if retrieval fails.</p> <p></p>"},{"location":"memories-storage-docs/storage/#save_resource_1","title":"save_resource","text":"<pre><code>def save_resource(user_id: str,\n                  resource_type: str,\n                  resource_id: str,\n                  metadata: Optional[ResourceMeta] = None,\n                  content_file: Optional[BytesIO] = None,\n                  content_id: Optional[int] = None,\n                  thumbnail_file: Optional[BytesIO] = None) -&gt; Optional[str]\n</code></pre> <p>Saves a resource by storing its metadata, content, and optional thumbnail.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_type</code> str - The type of the resource (e.g., 'books', 'documents').</li> <li><code>resource_id</code> str - A unique identifier for the resource.</li> <li><code>metadata</code> Optional[dict] - Structured metadata for the resource.</li> <li><code>content_file</code> Optional[BytesIO] - The content file as a BytesIO object.</li> <li><code>content_id</code> Optional[int] - The ID of the content.</li> <li><code>thumbnail_file</code> Optional[BytesIO] - Optional thumbnail image.</li> </ul> <p>Returns:</p> <ul> <li><code>Optional[str]</code> - The directory path where the resource was saved, or <code>None</code> if saving failed.</li> </ul> <p>Process:   1. Ensure the resource directory exists.   2. Save metadata, content, and optional thumbnails using parallel threads.   3. Validate storage success and handle errors gracefully.</p> <p></p>"},{"location":"memories-storage-docs/storage/#save_resource_meta_1","title":"save_resource_meta","text":"<pre><code>def save_resource_meta(user_id: str, resource_type: str, resource_id: str,\n                       metadata: ResourceMeta) -&gt; Optional[str]\n</code></pre> <p>Saves resource metadata using the primary <code>save_resource</code> method.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_type</code> str - The type of the resource (e.g., 'books', 'documents').</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> <li><code>metadata</code> dict - Metadata information to be saved.</li> </ul> <p>Returns:</p> <ul> <li><code>Optional[str]</code> - The directory path where the metadata was saved, or <code>None</code> if saving failed.</li> </ul> <p>Process:   1. Calls <code>save_resource()</code> with metadata to store it appropriately.   2. Returns the directory path of the saved resource metadata.</p> <p></p>"},{"location":"memories-storage-docs/storage/#delete_resource_1","title":"delete_resource","text":"<pre><code>def delete_resource(user_id: str, resource_type: str,\n                    resource_id: str) -&gt; bool\n</code></pre> <p>Deletes the specified resource and its associated directory.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_type</code> str - The type of the resource (e.g., 'books', 'documents').</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code> - <code>True</code> if the resource was successfully deleted, <code>False</code> otherwise.</li> </ul> <p>Process:   1. Determine the resource directory path.   2. Verify if the directory exists. If not, log a warning and return <code>False</code>.   3. Attempt to delete the directory and its contents.   4. Log success if deletion is successful, otherwise log the exception.</p> <p></p>"},{"location":"memories-storage-docs/storage/#delete_resource_content_1","title":"delete_resource_content","text":"<pre><code>def delete_resource_content(user_id: str, resource_type: str, resource_id: str,\n                            content_id: int) -&gt; bool\n</code></pre> <p>Deletes the specified content from the given resource.</p> <p>Arguments:</p> <ul> <li><code>user_id</code> str - The ID of the user who owns the resource.</li> <li><code>resource_type</code> str - The type of the resource (e.g., 'books', 'documents').</li> <li><code>resource_id</code> str - The unique identifier for the resource.</li> <li><code>content_id</code> int - The unique identifier for the content to be deleted.</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code> - <code>True</code> if the content was successfully deleted, <code>False</code> otherwise.</li> </ul> <p>Process:   1. Determine the resource directory path.   2. Verify if the directory exists. If not, log a warning and return <code>False</code>.   3. Identify matching content files using wildcard search.   4. If no matching files are found, log a warning and return <code>False</code>.   5. Delete each matching file and log the deletion status.   6. Return <code>True</code> upon successful deletion.</p> <p></p>"},{"location":"memories-storage-docs/storage/#storagelocal_backend","title":"storage.local_backend","text":""},{"location":"memories-storage-docs/storage/#localstoragebackend-objects","title":"LocalStorageBackend Objects","text":"<pre><code>class LocalStorageBackend(AbstractStorageBackend)\n</code></pre> <p>Handles resource storage using local file system.</p> <p></p>"},{"location":"memories-storage-docs/storage/#__init__","title":"__init__","text":"<pre><code>def __init__(base_dir=\"resources\")\n</code></pre> <p>Initializes the storage backend with a base directory.</p> <p></p>"},{"location":"memories-storage-docs/storage/#save","title":"save","text":"<pre><code>def save(user_id: str, resource_id: str, file_type: str, data: dict) -&gt; str\n</code></pre> <p>Saves JSON resource data to local storage.</p> <p></p>"},{"location":"memories-storage-docs/storage/#load","title":"load","text":"<pre><code>def load(user_id: str, resource_id: str, file_type: str) -&gt; dict | None\n</code></pre> <p>Loads JSON resource data from local storage.</p> <p></p>"},{"location":"memories-storage-docs/storage/#delete","title":"delete","text":"<pre><code>def delete(user_id: str, resource_id: str, file_type: str) -&gt; bool\n</code></pre> <p>Deletes a resource file from local storage.</p> <p></p>"},{"location":"memories-storage-docs/storage/#load_resource_meta_2","title":"load_resource_meta","text":"<pre><code>def load_resource_meta(user_id: str, resource_type: str,\n                       resource_id: str) -&gt; dict | None\n</code></pre> <p>Loads metadata for a given resource ID. Returns None if the resource does not exist.</p> <p></p>"},{"location":"memories-storage-docs/storage/#storagelocal_json_backend","title":"storage.local_json_backend","text":""},{"location":"memories-storage-docs/storage/#localstoragejsonbackend-objects","title":"LocalStorageJsonBackend Objects","text":"<pre><code>class LocalStorageJsonBackend(AbstractStorageBackend)\n</code></pre> <p>Handles resource storage using local JSON file system.</p> <p></p>"},{"location":"memories-storage-docs/storage/#__init___1","title":"__init__","text":"<pre><code>def __init__(base_dir=\"resources\")\n</code></pre> <p>Initializes the storage backend with a base directory.</p> <p></p>"},{"location":"memories-storage-docs/storage/#count_resources","title":"count_resources","text":"<pre><code>def count_resources(user_id: str, resource_type: str) -&gt; int\n</code></pre> <p>Counts the number of resources for a given user and type.</p> <p></p>"},{"location":"memories-storage-docs/storage/#save_resource_2","title":"save_resource","text":"<pre><code>def save_resource(user_id: str,\n                  resource_type: str,\n                  resource_id: str,\n                  metadata: dict,\n                  content: bytes = b\"\",\n                  thumbnail: bytes = b\"\") -&gt; str\n</code></pre> <p>Saves a resource in a thread-safe JSON structure.</p> <p></p>"},{"location":"memories-storage-docs/storage/#load_resource","title":"load_resource","text":"<pre><code>def load_resource(user_id: str, resource_type: str,\n                  resource_id: str) -&gt; dict | None\n</code></pre> <p>Loads a resource in a thread-safe manner.</p> <p></p>"},{"location":"memories-storage-docs/storage/#delete_resource_2","title":"delete_resource","text":"<pre><code>def delete_resource(user_id: str, resource_type: str,\n                    resource_id: str) -&gt; bool\n</code></pre> <p>Deletes a resource in a thread-safe manner.</p> <p></p>"},{"location":"memories-storage-docs/storage/#load_resource_meta_3","title":"load_resource_meta","text":"<pre><code>def load_resource_meta(user_id: str, resource_type: str,\n                       resource_id: str) -&gt; dict | None\n</code></pre> <p>Loads metadata for a given resource from JSON storage. Returns None if the resource does not exist.</p>"},{"location":"memories-storage-docs/utils/","title":"Utils","text":""},{"location":"memories-storage-docs/utils/#utils","title":"utils","text":""},{"location":"memories-storage-docs/utils/#utilsfile_utils","title":"utils.file_utils","text":""},{"location":"memories-storage-docs/utils/#get_mimetype","title":"get_mimetype","text":"<pre><code>def get_mimetype(file) -&gt; Optional[str]\n</code></pre> <p>Gets the MIME type of a file.</p> <p>Arguments:</p> <ul> <li><code>file</code>: File object or file path</li> </ul> <p>Returns:</p> <p>MIME type (e.g., \"image/jpeg\", \"application/pdf\")</p> <p></p>"},{"location":"memories-storage-docs/utils/#get_extension_from_mimetype","title":"get_extension_from_mimetype","text":"<pre><code>def get_extension_from_mimetype(mimetype, file_category)\n</code></pre> <p>MIME \u30bf\u30a4\u30d7\u304b\u3089\u62e1\u5f35\u5b50\u3092\u53d6\u5f97</p> <p></p>"},{"location":"memories-storage-docs/utils/#get_mimetype_from_extension","title":"get_mimetype_from_extension","text":"<pre><code>def get_mimetype_from_extension(extension: str, file_category: str) -&gt; str\n</code></pre> <p>\u62e1\u5f35\u5b50\u304b\u3089 MIME \u30bf\u30a4\u30d7\u3092\u53d6\u5f97</p> <p></p>"},{"location":"memories-storage-docs/utils/#sanitize_filename","title":"sanitize_filename","text":"<pre><code>def sanitize_filename(filename: Optional[str]) -&gt; Optional[str]\n</code></pre> <p>\u30d5\u30a1\u30a4\u30eb\u540d\u3092\u5b89\u5168\u306a\u5f62\u5f0f\u306b\u30b5\u30cb\u30bf\u30a4\u30ba\u3059\u308b\u3002</p> <p></p>"},{"location":"memories-storage-docs/utils/#utilsmisc","title":"utils.misc","text":""}]}